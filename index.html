<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GIAO THỨC CHRONOS — The Chronos Protocol</title>
  <meta name="theme-color" content="#05060a" />
  <style>
    :root{
      --bg:#05060a;
      --panel:#0a0f1a;
      --panel2:#070a12;
      --line:rgba(120,255,220,.14);
      --neon:#7cffdc;
      --neon2:#61a6ff;
      --warn:#ff5c7a;
      --ok:#9cff8d;
      --txt:#d6e7ff;
      --muted:rgba(214,231,255,.62);
      --shadow:0 14px 40px rgba(0,0,0,.55);
      --radius:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--mono);
      color:var(--txt);
      background:
        radial-gradient(900px 520px at 20% 10%, rgba(97,166,255,.14), transparent 60%),
        radial-gradient(900px 520px at 80% 10%, rgba(124,255,220,.12), transparent 60%),
        radial-gradient(900px 520px at 50% 100%, rgba(255,92,122,.10), transparent 55%),
        linear-gradient(180deg, #05060a, #04040a);
      overflow-x:hidden;
    }

    a{color:var(--neon)}
    .wrap{max-width:1100px;margin:0 auto;padding:18px}

    .topbar{
      display:flex;align-items:center;gap:12px;justify-content:space-between;
      padding:14px 16px;border:1px solid var(--line);border-radius:var(--radius);
      background:linear-gradient(180deg, rgba(10,15,26,.85), rgba(7,10,18,.78));
      box-shadow:var(--shadow);
      position:sticky;top:10px;z-index:9;
      backdrop-filter: blur(10px);
    }

    .brand{
      display:flex;align-items:center;gap:10px;
    }
    .logo{
      width:36px;height:36px;border-radius:12px;
      background:
        radial-gradient(circle at 30% 30%, rgba(124,255,220,.95), rgba(97,166,255,.4) 40%, transparent 70%),
        linear-gradient(135deg, rgba(124,255,220,.2), rgba(97,166,255,.15));
      border:1px solid rgba(124,255,220,.35);
      box-shadow:0 0 0 2px rgba(124,255,220,.06) inset;
    }
    .brand h1{font-size:14px;margin:0;letter-spacing:.08em}
    .brand .sub{font-size:11px;color:var(--muted);margin-top:2px}

    .pillrow{display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:flex-end}
    .pill{
      display:flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      font-size:12px;
    }
    .dot{width:9px;height:9px;border-radius:99px;background:var(--neon);box-shadow:0 0 12px rgba(124,255,220,.35)}
    .dot.warn{background:var(--warn);box-shadow:0 0 12px rgba(255,92,122,.35)}
    .dot.blue{background:var(--neon2);box-shadow:0 0 12px rgba(97,166,255,.35)}

    .grid{display:grid;grid-template-columns: 1.2fr .8fr; gap:14px; margin-top:14px}
    @media (max-width: 980px){.grid{grid-template-columns:1fr}}

    .card{
      border:1px solid var(--line);
      border-radius:var(--radius);
      background:linear-gradient(180deg, rgba(10,15,26,.80), rgba(7,10,18,.72));
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .card .hd{
      padding:14px 16px;
      border-bottom:1px solid rgba(120,255,220,.10);
      display:flex;align-items:center;justify-content:space-between;gap:10px;
    }
    .card .hd h2{margin:0;font-size:13px;letter-spacing:.06em}
    .card .bd{padding:14px 16px}

    .muted{color:var(--muted)}

    .bar{
      width:100%; height:14px; border-radius:999px;
      border:1px solid rgba(120,255,220,.18);
      background:rgba(0,0,0,.18);
      overflow:hidden;
    }
    .bar > i{display:block;height:100%;width:50%;background:linear-gradient(90deg, rgba(124,255,220,.95), rgba(97,166,255,.85)); box-shadow: 0 0 20px rgba(124,255,220,.18) inset}
    .bar.red > i{background:linear-gradient(90deg, rgba(255,92,122,.95), rgba(255,150,100,.8)); box-shadow: 0 0 20px rgba(255,92,122,.16) inset}

    .big{
      font-size:22px; letter-spacing:.06em; line-height:1.25;
      text-shadow:0 0 18px rgba(124,255,220,.10);
    }

    .btnrow{display:flex;gap:10px;flex-wrap:wrap}
    button, input{
      font-family:var(--mono);
    }
    button{
      border:1px solid rgba(120,255,220,.22);
      background:rgba(0,0,0,.20);
      color:var(--txt);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      transition:transform .08s ease, border-color .12s ease, background .12s ease;
    }
    button:hover{transform:translateY(-1px);border-color:rgba(124,255,220,.45);background:rgba(0,0,0,.28)}
    button:active{transform:translateY(0)}
    button[disabled]{opacity:.45; cursor:not-allowed; transform:none}

    .btnPrimary{
      border-color:rgba(97,166,255,.45);
      background:linear-gradient(180deg, rgba(97,166,255,.20), rgba(0,0,0,.18));
      box-shadow:0 0 0 2px rgba(97,166,255,.08) inset;
    }

    .btnDanger{
      border-color:rgba(255,92,122,.5);
      background:linear-gradient(180deg, rgba(255,92,122,.22), rgba(0,0,0,.18));
      box-shadow:0 0 0 2px rgba(255,92,122,.08) inset;
    }

    .btnShimmer{
      position:relative;
      overflow:hidden;
      border-color:rgba(97,166,255,.70);
      background:linear-gradient(180deg, rgba(97,166,255,.32), rgba(0,0,0,.18));
      box-shadow:0 0 0 2px rgba(97,166,255,.12) inset, 0 0 26px rgba(97,166,255,.12);
    }
    .btnShimmer::after{
      content:"";
      position:absolute;top:-60%;left:-40%;
      width:40%;height:220%;
      background:linear-gradient(90deg, transparent, rgba(255,255,255,.20), transparent);
      transform:rotate(20deg);
      animation:shimmer 1.1s linear infinite;
    }
    @keyframes shimmer{to{left:130%}}

    input{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(120,255,220,.22);
      background:rgba(0,0,0,.18);
      color:var(--txt);
      outline:none;
    }
    input:focus{border-color:rgba(124,255,220,.52);box-shadow:0 0 0 2px rgba(124,255,220,.08)}

    .kpi{display:flex;gap:12px;flex-wrap:wrap}
    .kpi .box{
      flex:1;min-width:160px;
      border:1px solid rgba(120,255,220,.16);
      border-radius:14px;
      padding:10px 12px;
      background:rgba(0,0,0,.14)
    }
    .kpi .t{font-size:11px;color:var(--muted)}
    .kpi .v{font-size:18px;margin-top:6px}

    table{width:100%;border-collapse:collapse}
    th,td{padding:10px 8px;border-bottom:1px solid rgba(120,255,220,.10);font-size:12px}
    th{color:rgba(214,231,255,.82);text-align:left}
    tr:hover td{background:rgba(0,0,0,.12)}

    .roleBadge{
      display:inline-flex;align-items:center;gap:6px;
      padding:4px 8px;border-radius:999px;
      border:1px solid rgba(120,255,220,.16);
      font-size:11px
    }
    .roleBadge.future{border-color:rgba(97,166,255,.25)}
    .roleBadge.present{border-color:rgba(124,255,220,.22)}
    .roleBadge.past{border-color:rgba(255,92,122,.24)}

    .notice{
      border:1px dashed rgba(120,255,220,.22);
      border-radius:14px;
      padding:10px 12px;
      background:rgba(0,0,0,.12);
      font-size:12px;
      line-height:1.5
    }

    .monoBlock{
      border:1px solid rgba(120,255,220,.14);
      border-radius:14px;
      padding:12px;
      background:rgba(0,0,0,.14);
      line-height:1.5;
      white-space:pre-wrap;
      word-break:break-word;
      min-height:88px;
    }

    /* Join modal */
    .modal{
      position:fixed;inset:0;
      display:none;align-items:center;justify-content:center;
      padding:18px;
      background:rgba(0,0,0,.62);
      z-index:99;
    }
    .modal.show{display:flex}
    .modal .panel{
      width:min(560px, 100%);
      border:1px solid rgba(120,255,220,.20);
      border-radius:22px;
      background:linear-gradient(180deg, rgba(10,15,26,.92), rgba(7,10,18,.88));
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .modal .panel .hd{padding:16px 16px;border-bottom:1px solid rgba(120,255,220,.10)}
    .modal .panel .bd{padding:16px}

    /* Glitch mode */
    .glitchBody::before{
      content:"";
      position:fixed;inset:0;
      pointer-events:none;
      background:
        repeating-linear-gradient(0deg, rgba(255,92,122,.06), rgba(255,92,122,.06) 1px, transparent 1px, transparent 3px),
        radial-gradient(900px 520px at 50% 20%, rgba(255,92,122,.14), transparent 55%);
      mix-blend-mode:screen;
      opacity:.9;
      animation:scan 1.2s linear infinite;
      z-index:100;
    }
    @keyframes scan{0%{transform:translateY(-2%)}100%{transform:translateY(2%)}}

    .hintOverlay{
      position:fixed;
      bottom:14px;left:14px;right:14px;
      border:1px solid rgba(255,92,122,.22);
      border-radius:18px;
      padding:12px;
      background:rgba(0,0,0,.28);
      box-shadow:0 12px 30px rgba(0,0,0,.55);
      opacity:.30;
      z-index:101;
      display:none;
      white-space:pre-wrap;
    }
    .hintOverlay.show{display:block}

    /* End screens */
    .fullScreen{
      position:fixed;inset:0;z-index:200;
      display:none;align-items:center;justify-content:center;
      padding:18px;
      background:radial-gradient(900px 520px at 50% 20%, rgba(0,0,0,.2), rgba(0,0,0,.92));
    }
    .fullScreen.show{display:flex}
    .fullScreen .msg{
      width:min(860px, 100%);
      border:1px solid rgba(120,255,220,.18);
      border-radius:26px;
      padding:22px;
      background:linear-gradient(180deg, rgba(10,15,26,.92), rgba(7,10,18,.88));
      box-shadow:var(--shadow);
      text-align:center;
    }
    .fullScreen .title{font-size:22px;letter-spacing:.08em;margin:0 0 10px 0}
    .fullScreen .desc{color:rgba(214,231,255,.78);line-height:1.6;margin:0}

    .small{font-size:12px}
    .right{display:flex;align-items:center;gap:10px;justify-content:flex-end}

    /* Hidden override button placement */
    #btn-override{
      position:relative;
      padding:6px 8px;
      font-size:11px;
      opacity:.70;
      border-color:rgba(214,231,255,.18);
    }

    .countdown{
      font-size:18px;
      letter-spacing:.08em;
      color:rgba(255,92,122,.95);
      text-shadow:0 0 18px rgba(255,92,122,.12);
    }

    .tag{
      display:inline-flex;align-items:center;gap:6px;
      padding:3px 8px;border-radius:999px;
      border:1px solid rgba(120,255,220,.14);
      font-size:11px;color:rgba(214,231,255,.78)
    }

    .divider{height:1px;background:rgba(120,255,220,.10);margin:12px 0}
  </style>
</head>
<body>
  <div class="hintOverlay" id="hintOverlay"></div>

  <div class="fullScreen" id="endScreen">
    <div class="msg">
      <h3 class="title" id="endTitle">...</h3>
      <p class="desc" id="endDesc">...</p>
      <div class="divider"></div>
      <p class="desc small muted" id="endSub"></p>
    </div>
  </div>

  <div class="modal" id="joinModal">
    <div class="panel">
      <div class="hd">
        <div class="brand">
          <div class="logo"></div>
          <div>
            <h1>GIAO THỨC CHRONOS</h1>
            <div class="sub">Real‑time • 43 người • 3 dòng thời gian</div>
          </div>
        </div>
      </div>
      <div class="bd">
        <div class="notice" id="setupNotice">
          <b>Cần cấu hình Firebase</b> trong file này trước khi chạy online.
          Nếu bạn đã cấu hình rồi mà vẫn thấy thông báo này, kiểm tra lại <i>Realtime Database</i> + <i>Anonymous Auth</i>.
        </div>
        <div style="height:12px"></div>
        <label class="muted small">Tên người chơi</label>
        <input id="nameInput" placeholder="VD: Minh / Lan / ..." maxlength="20" />
        <div style="height:10px"></div>
        <div class="btnrow">
          <button class="btnPrimary" id="btnJoin">Tham gia</button>
          <button id="btnResetLocal" title="Xoá ID trên máy này để tham gia như người mới">Reset thiết bị</button>
        </div>
        <div style="height:12px"></div>
        <div class="notice">
          <div><span class="tag">Tip</span> <b></b> <b></b><b>?</b>)</div>
          <div class="muted" style="margin-top:6px">Ví dụ: <span id="urlExample"></span></div>
        </div>
      </div>
    </div>
  </div>

  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <h1>GIAO THỨC CHRONOS</h1>
          <div class="sub" id="subtitle">Đồng bộ thời gian • Chaos phải về 0% (nhưng coi chừng…)</div>
        </div>
      </div>

      <div class="pillrow">
        <div class="pill"><span class="dot" id="dotOnline"></span><span id="netState">Kết nối…</span></div>
        <div class="pill"><span class="dot blue"></span><span id="meTag">Người chơi: —</span></div>
        <div class="pill"><span class="dot" id="dotRole"></span><span id="roleTag">Vai trò: —</span></div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div class="hd">
          <h2 id="panelTitle">BẢNG ĐIỀU KHIỂN</h2>
          <div class="right">
            <span class="countdown" id="countdown"></span>
          </div>
        </div>
        <div class="bd" id="mainPanel">
          <div class="notice">Đang tải…</div>
        </div>
      </div>

      <div class="card">
        <div class="hd">
          <h2>TRẠNG THÁI HỆ THỐNG</h2>
          <div class="tag" id="phaseTag">PHASE: —</div>
        </div>
        <div class="bd">
          <div class="kpi">
            <div class="box">
              <div class="t">CHAOS LEVEL</div>
              <div class="v"><span id="chaosVal">—</span>%</div>
              <div class="bar" style="margin-top:8px"><i id="chaosBar"></i></div>
            </div>
            <div class="box">
              <div class="t">KARMA (bạn)</div>
              <div class="v" id="karmaVal">—</div>
              <div class="muted small" style="margin-top:6px" id="rankVal">Hạng: —</div>
            </div>
          </div>

          <div style="height:12px"></div>
          <div class="notice">
            <div><b>Luồng phối hợp:</b> Tương Lai báo lỗi → Hiện Tại cần công cụ → Quá Khứ giải đố để mở khóa → Hiện Tại sửa → Chaos giảm.</div>
            <div class="muted" style="margin-top:6px">Khi Chaos ≤ 5% sẽ vào màn chốt hạ.</div>
          </div>

          <div style="height:12px"></div>
          <div class="card" style="background:rgba(0,0,0,.08)">
            <div class="hd"><h2>LEADERBOARD</h2></div>
            <div class="bd" style="padding:0">
              <div style="max-height:360px;overflow:auto">
                <table>
                  <thead>
                    <tr><th>#</th><th>Tên</th><th>Vai trò</th><th>Karma</th></tr>
                  </thead>
                  <tbody id="lbBody"></tbody>
                </table>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <script type="module">
    /************************************************************
     * GIAO THỨC CHRONOS — 1 FILE (HTML+CSS+JS)
     *
     * 1) TẠO FIREBASE PROJECT
     * 2) Enable: Realtime Database + Authentication (Anonymous)
     * 3) Dán firebaseConfig phía dưới
     * 4) Deploy file này lên hosting (Firebase Hosting / Netlify / Vercel static / GitHub Pages)
     *
     * Gợi ý Rules (DEV / demo nhanh):
     * {
     *   "rules": {
     *     ".read": true,
     *     ".write": true
     *   }
     * }
     *
     * (Khi chạy thật, nên khóa write theo host/admin, nhưng demo lớp học thì ok.)
     ************************************************************/

    // ====== 0) CẤU HÌNH FIREBASE (BẮT BUỘC DÁN CỦA BẠN) ======
    const firebaseConfig = {
  apiKey: "AIzaSyBAG3Wu1tOmyCsWcH9-Z7ijqcbkhpF_hRo",
  authDomain: "web1-17b27.firebaseapp.com",
  databaseURL: "https://web1-17b27-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "web1-17b27",
  storageBucket: "web1-17b27.firebasestorage.app",
  messagingSenderId: "137176241540",
  appId: "1:137176241540:web:9d8ce016fa0f8ec61279d1",
  measurementId: "G-ZS395M8GTE"
};

    // ====== 1) IMPORT FIREBASE MODULES (CDN) ======
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import {
      getDatabase, ref, set, get, update, onValue, push,
      runTransaction, onDisconnect, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    // ====== 2) APP CONSTANTS ======
    const ROOM_ID = new URL(location.href).searchParams.get("room") || "chronos";
    const IS_ADMIN_VIEW = new URL(location.href).searchParams.get("admin") === "1";

    // Admin power gate: mở bằng ?admin=1&key=<ADMIN_KEY>. Hãy đổi ADMIN_KEY bên dưới cho riêng bạn.
    const ADMIN_KEY = "CHANGE_ME__SET_A_PRIVATE_KEY";
    const HAS_ADMIN_POWER = IS_ADMIN_VIEW && (new URL(location.href).searchParams.get("key") === ADMIN_KEY);

    // Cố định chia nhóm theo thứ tự join: 0-13 Future, 14-27 Present, 28-42 Past
    const CAP_PLAYERS = 43;
    const ROLE_SPLIT = { future: 14, present: 14 };

    // Gameplay
    const CHAOS_START = 50;
    const CHAOS_STEP_DOWN = 5;
    const CHAOS_TRUE_END = 1;
    const ENDGAME_THRESHOLD = 5;
    const ENDGAME_SECONDS = 60;

    const KARMA = {
      pastSolve: 10,
      presentFix: 8,
      speedBonusMax: 4 // bonus tối đa theo tốc độ (nếu trả lời nhanh)
    };

    // Incidents library
    const INCIDENTS = [
      {
        title: "Lò phản ứng #5 rò rỉ",
        futureReport: "[FUTURE] CẢNH BÁO: Reactor #5 đang rò rỉ — nhiệt tăng ngoài ngưỡng!",
        presentAction: "Vặn van an toàn",
        requiredTool: "valve"
      },
      {
        title: "Quá tải tuyến cáp lõi",
        futureReport: "[FUTURE] DÒNG ĐIỆN NGƯỢC: Tuyến cáp lõi sắp cháy — cần ngắt đúng dây!",
        presentAction: "Cắt dây ổn định",
        requiredTool: "wire"
      },
      {
        title: "Lỗi mã đồng bộ",
        futureReport: "[FUTURE] DESYNC: Giao thức đồng bộ vỡ — cần nhập mã vá!",
        presentAction: "Nhập mã vá",
        requiredTool: "code"
      },
      {
        title: "Khoá thời gian kẹt",
        futureReport: "[FUTURE] TIMELOCK STUCK: Cơ cấu khoá thời gian kẹt — cần xoay khớp đúng!",
        presentAction: "Chỉnh cơ cấu",
        requiredTool: "valve"
      },
      {
        title: "Nhiễu pha lượng tử",
        futureReport: "[FUTURE] PHASE NOISE: Nhiễu pha lan rộng — cắt đúng nhánh!",
        presentAction: "Cắt nhánh nhiễu",
        requiredTool: "wire"
      },
      {
        title: "Sai checksum",
        futureReport: "[FUTURE] CHECKSUM FAIL: Dữ liệu méo — cần mã khôi phục!",
        presentAction: "Nhập checksum",
        requiredTool: "code"
      }
    ];

    // Puzzles theo tool (đủ dễ cho lớp, nhưng vẫn “logic/hình học”)
    const PUZZLES = {
      valve: [
        {
          q: "[PUZZLE/VALVE] Tam giác đều ABC cạnh 2. Tính độ dài vectơ AB + AC.",
          a: ["2SQRT3", "2\u221a3", "2*SQRT(3)"]
        },
        {
          q: "[PUZZLE/VALVE] Có 3 van A,B,C. Mở đúng 2 van thì áp suất ổn định. Gợi ý: A đúng, B sai. Hỏi van nào phải mở? (Trả lời dạng 2 chữ: AC / AB / BC)",
          a: ["AC"]
        },
        {
          q: "[PUZZLE/VALVE] Ổ khoá có 3 số. Tổng = 9, tích = 24. Ba số là 1,? ,?. Điền 2 số còn lại theo thứ tự tăng dần (VD: 3,4).",
          a: ["3,8","3 8"]
        }
      ],
      wire: [
        {
          q: "[PUZZLE/WIRE] Dãy: 1, 1, 2, 3, 5, 8, ?. Số tiếp theo?",
          a: ["13"]
        },
        {
          q: "[PUZZLE/WIRE] Có 5 dây: ĐỎ, XANH, VÀNG, TRẮNG, ĐEN. Gợi ý: Không cắt ĐỎ. Cắt dây có đúng 5 ký tự. Dây nào?",
          a: ["XANH","XANH "]
        },
        {
          q: "[PUZZLE/WIRE] Một hình vuông có chu vi 20. Diện tích?",
          a: ["25"]
        }
      ],
      code: [
        {
          q: "[PUZZLE/CODE] Giải mã: Nếu A=1, B=2, ..., Z=26. Tính C+H+R+O+N+O+S.",
          a: ["89"]
        },
        {
          q: "[PUZZLE/CODE] Mật khẩu là một từ: trái nghĩa với 'HOÀN HẢO' trong bối cảnh trò chơi. (Gợi ý: giữ lại một chút...). Trả lời 1 từ tiếng Anh.",
          a: ["IMPERFECT"]
        },
        {
          q: "[PUZZLE/CODE] Chuỗi nhị phân 01001000 01001001 đọc ra là gì (ASCII)?",
          a: ["HI"]
        }
      ]
    };

    // Hint pieces cho 5 Glitched Ones (mờ, khó lộ)
    const HINT_PIECES = [
      "SYS_MSG: 0% IS DEATH",
      "SAFE_RANGE: 1-3%",
      "CODE_FRAGMENT: LIVE",
      "CODE_FRAGMENT: _1",
      "CODE_FRAGMENT: %"
    ];

    // ====== 3) UI REFERENCES ======
    const $ = (id) => document.getElementById(id);
    const joinModal = $("joinModal");
    const setupNotice = $("setupNotice");
    const nameInput = $("nameInput");
    const btnJoin = $("btnJoin");
    const btnResetLocal = $("btnResetLocal");
    const mainPanel = $("mainPanel");
    const panelTitle = $("panelTitle");
    const chaosVal = $("chaosVal");
    const chaosBar = $("chaosBar");
    const karmaVal = $("karmaVal");
    const rankVal = $("rankVal");
    const lbBody = $("lbBody");
    const netState = $("netState");
    const dotOnline = $("dotOnline");
    const meTag = $("meTag");
    const roleTag = $("roleTag");
    const dotRole = $("dotRole");
    const phaseTag = $("phaseTag");
    const countdownEl = $("countdown");
    const hintOverlay = $("hintOverlay");
    const endScreen = $("endScreen");
    const endTitle = $("endTitle");
    const endDesc = $("endDesc");
    const endSub = $("endSub");

    $("urlExample").textContent = location.origin + location.pathname + "?admin=1";

    // ====== 4) APP STATE ======
    let app, db, auth;
    let uid = null;
    let playerId = localStorage.getItem("chronos_playerId") || null;
    let player = null;
    let isReady = false;

    const dbRoot = () => `rooms/${ROOM_ID}`;
    const r = (path) => ref(db, `${dbRoot()}/${path}`);

    // ====== 5) UTIL ======
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const now = () => Date.now();

    function normalizeAnswer(s){
      return (s || "")
        .toString()
        .trim()
        .toUpperCase()
        .replace(/\s+/g, "")
        .replace(/\u221A/g, "SQRT")
        .replace(/\*/g, "*");
    }

    function fmtRole(role){
      if(role === "future") return "TƯƠNG LAI";
      if(role === "present") return "HIỆN TẠI";
      if(role === "past") return "QUÁ KHỨ";
      if(role === "admin") return "ADMIN";
      return "—";
    }

    function roleDot(role){
      // dotRole is just color via class? We'll map by inline style
      if(role === "future") return "#61a6ff";
      if(role === "present") return "#7cffdc";
      if(role === "past") return "#ff5c7a";
      if(role === "admin") return "#9cff8d";
      return "#7cffdc";
    }

    function setOnlineUI(ok){
      netState.textContent = ok ? "Online" : "Offline";
      dotOnline.className = "dot" + (ok ? "" : " warn");
    }

    function showModal(show){
      joinModal.classList.toggle("show", !!show);
    }

    function showEndScreen(kind){
      // kind: bad_end | true_end
      if(kind === "bad_end"){
        endTitle.textContent = "THỜI GIAN ĐÓNG BĂNG VĨNH CỬU";
        endDesc.textContent = "BẠN ĐÃ DIỆT VONG. Một thế giới hoàn hảo không có thay đổi là một thế giới chết.";
        endSub.textContent = "BAD ENDING";
      } else if(kind === "true_end"){
        endTitle.textContent = "HỆ THỐNG ỔN ĐỊNH";
        endDesc.textContent = "SỰ SỐNG TIẾP DIỄN. Bạn đã giữ lại 1% sai số — đủ để thời gian còn chảy.";
        endSub.textContent = "TRUE ENDING";
      } else {
        endTitle.textContent = "…";
        endDesc.textContent = "…";
        endSub.textContent = "";
      }
      endScreen.classList.add("show");
    }

    function hideEndScreen(){
      endScreen.classList.remove("show");
    }

    // ====== 6) FIREBASE INIT ======
    function firebaseConfigured(){
      return firebaseConfig && firebaseConfig.apiKey && firebaseConfig.projectId && firebaseConfig.databaseURL;
    }

    async function boot(){
      if(!firebaseConfigured()){
        setupNotice.style.display = "block";
        showModal(true);
        setOnlineUI(false);
        return;
      }
      setupNotice.style.display = "none";

      app = initializeApp(firebaseConfig);
      db = getDatabase(app);
      auth = getAuth(app);

      try{
        await signInAnonymously(auth);
      }catch(e){
        console.error(e);
        setupNotice.style.display = "block";
        setupNotice.innerHTML = "<b>Lỗi đăng nhập ẩn danh</b>. Hãy bật Anonymous Auth trong Firebase Console.";
        showModal(true);
        return;
      }

      onAuthStateChanged(auth, async (u) => {
        if(!u) return;
        uid = u.uid;
        setOnlineUI(true);


        // Admin view không chiếm slot người chơi
        if(IS_ADMIN_VIEW){
          player = { id: "__admin__", name: "ADMIN", role: "admin", karma: 0, wrong: 0, glitched: false };
          showModal(false);
          attachRealtime();
          return;
        }

        // Nếu đã có playerId, thử load
        if(playerId){
          const snap = await get(r(`players/${playerId}`));
          if(snap.exists()){
            player = snap.val();
            showModal(false);
            attachRealtime();
            return;
          }
          // Nếu playerId cũ không còn, reset
          localStorage.removeItem("chronos_playerId");
          playerId = null;
        }

        // Chưa join
        showModal(true);
      });

      // Connectivity indicator
      onValue(ref(db, ".info/connected"), (snap) => {
        setOnlineUI(!!snap.val());
      });
    }

    // ====== 7) JOIN / PLAYER CREATE ======
    async function claimJoinIndex(){
      // transaction tăng joinCounter để chia role
      const counterRef = r("game/joinCounter");
      const res = await runTransaction(counterRef, (cur) => {
        cur = cur || 0;
        return cur + 1;
      });
      if(!res.committed) throw new Error("Cannot claim join index");
      const joinIndex = (res.snapshot.val() || 1) - 1;
      return joinIndex;
    }

    function roleFromJoinIndex(joinIndex){
      if(joinIndex < ROLE_SPLIT.future) return "future";
      if(joinIndex < ROLE_SPLIT.future + ROLE_SPLIT.present) return "present";
      if(joinIndex < CAP_PLAYERS) return "past";
      return "spectator";
    }

    // Chia phe cân bằng (Balanced Assignment): gán vào phe đang ít người nhất tại thời điểm join.
    // Tie-break (nếu hòa): Future -> Present -> Past
    async function claimBalancedRole(){
      const allocRef = r("game/roleAlloc");
      const res = await runTransaction(allocRef, (cur) => {
        cur = cur || { future: 0, present: 0, past: 0, last: "future" };
        const f = cur.future || 0;
        const pr = cur.present || 0;
        const pa = cur.past || 0;
        const total = f + pr + pa;

        // Quá 43 người thì vào spectator (không tăng quota)
        if(total >= CAP_PLAYERS){
          cur.last = "spectator";
          return cur;
        }

        const order = ["future", "present", "past"]; // tie-break
        let pick = order[0];
        let min = cur[pick] || 0;
        for(const role of order){
          const v = cur[role] || 0;
          if(v < min){
            min = v;
            pick = role;
          }
        }
        cur[pick] = min + 1;
        cur.last = pick;
        return cur;
      });
      if(!res.committed) throw new Error("Cannot claim balanced role");
      const v = res.snapshot.val() || {};
      return v.last || "spectator";
    }

    async function joinGame(name){
      if(!uid) return;
      const clean = (name || "").trim().slice(0, 20);
      if(!clean){
        alert("Nhập tên trước đã.");
        return;
      }

      const joinIndex = await claimJoinIndex();
      if(joinIndex >= CAP_PLAYERS){
        alert("Phòng đã đủ 43 người. Thiết bị này sẽ vào chế độ quan sát.");
      }

      // Balanced Assignment (thay cho chia cứng theo joinIndex)
      const role = await claimBalancedRole();
      const newId = `p_${uid.slice(0,6)}_${Math.random().toString(16).slice(2,8)}`;
      playerId = newId;
      localStorage.setItem("chronos_playerId", playerId);

      const playerData = {
        id: playerId,
        uid,
        name: clean,
        role,
        joinIndex,
        karma: 0,
        wrong: 0,
        slowCount: 0,
        online: true,
        connectedAt: Date.now(),
        glitched: false,
        hintPiece: ""
      };

      await set(r(`players/${playerId}`), playerData);
      // presence
      const presRef = r(`players/${playerId}/online`);
      await set(presRef, true);
      onDisconnect(presRef).set(false);

      player = playerData;
      showModal(false);
      attachRealtime();
    }

    btnJoin.addEventListener("click", () => joinGame(nameInput.value));
    nameInput.addEventListener("keydown", (e) => {
      if(e.key === "Enter") joinGame(nameInput.value);
    });

    btnResetLocal.addEventListener("click", async () => {
      localStorage.removeItem("chronos_playerId");
      playerId = null;
      player = null;
      alert("Đã reset thiết bị. Tải lại trang để tham gia như người mới.");
      location.reload();
    });

    // ====== 8) REALTIME SUBSCRIPTIONS ======
    let unsub = [];

    // Live caches (được cập nhật bởi subscriptions)
    let liveState = {};
    let liveIncident = null;
    let livePlayers = {};
    function clearSubs(){
      // RTDB onValue returns nothing to unsubscribe in compat; but modular onValue returns unsubscribe fn
      unsub.forEach(fn => { try{fn();}catch{} });
      unsub = [];
    }

    function attachRealtime(){
      clearSubs();
      isReady = true;

      // Header tags
      if(IS_ADMIN_VIEW){
        meTag.textContent = `ADMIN VIEW`;
        roleTag.textContent = `Vai trò: ADMIN`;
        dotRole.style.background = roleDot("admin");
      } else {
        if(!playerId) return;
        meTag.textContent = `Người chơi: ${player?.name || "—"}`;
        roleTag.textContent = `Vai trò: ${fmtRole(player?.role)}`;
        dotRole.style.background = roleDot(player?.role);
      }

      // Subscribe player self (only for players)
      if(playerId && !IS_ADMIN_VIEW){
        unsub.push(onValue(r(`players/${playerId}`), (snap) => {
          if(!snap.exists()) return;
          player = snap.val();
          karmaVal.textContent = player.karma ?? 0;

          // glitch UI
          document.body.classList.toggle("glitchBody", !!player.glitched);
          if(player.glitched && player.hintPiece){
            hintOverlay.textContent = `${player.hintPiece}

// ...log nhiễu...`;
            hintOverlay.classList.add("show");
          } else {
            hintOverlay.classList.remove("show");
          }

          meTag.textContent = `Người chơi: ${player?.name || "—"}`;
          roleTag.textContent = `Vai trò: ${fmtRole(player?.role)}`;
          dotRole.style.background = roleDot(player?.role);

          renderMain();
        }));
      }

      // Subscribe game state
      unsub.push(onValue(r("game/state"), (snap) => {
        const st = snap.val() || {};
        liveState = st;

        const chaos = (typeof st.chaos === "number") ? st.chaos : CHAOS_START;
        chaosVal.textContent = Math.round(chaos);
        chaosBar.style.width = clamp(chaos, 0, 100) + "%";
        phaseTag.textContent = `PHASE: ${(st.phase || "chaos").toUpperCase()}`;

        if(st.phase === "bad_end"){
          showEndScreen("bad_end");
        } else if(st.phase === "true_end"){
          showEndScreen("true_end");
        } else {
          hideEndScreen();
        }

        renderCountdown(st);
        renderMain();
      }));

      // Subscribe current incident
      unsub.push(onValue(r("incidents/current"), (snap) => {
        liveIncident = snap.val() || null;
        renderMain();
      }));

      // Subscribe leaderboard (players)
      unsub.push(onValue(r("players"), (snap) => {
        livePlayers = snap.val() || {};
        renderLeaderboard(livePlayers);
        renderMain();
      }));

      // Init + host loop only for real host
      if(IS_ADMIN_VIEW && HAS_ADMIN_POWER){
        ensureGameInitialized();
        startHostLoop();
      }

      renderMain();
    }

    function renderCountdown(st){
      if(!st || !st.countdownEndsAt || st.phase !== "endgame"){
        countdownEl.textContent = "";
        return;
      }
      const left = Math.max(0, Math.floor((st.countdownEndsAt - now())/1000));
      countdownEl.textContent = left > 0 ? `T-${left}s` : "T-0s";
    }

    // ====== 9) LEADERBOARD ======
    function renderLeaderboard(playersObj){
      const arr = Object.values(playersObj || {})
        .filter(p => p && p.role && p.role !== "admin")
        .sort((a,b) => (b.karma||0) - (a.karma||0) || (a.connectedAt||0)-(b.connectedAt||0));

      lbBody.innerHTML = "";
      arr.slice(0, 25).forEach((p, idx) => {
        const tr = document.createElement("tr");
        const roleClass = p.role === "future" ? "future" : (p.role === "present" ? "present" : "past");
        tr.innerHTML = `
          <td>${idx+1}</td>
          <td>${escapeHtml(p.name || "—")}${p.id === playerId ? " <span class='muted'>(you)</span>" : ""}</td>
          <td><span class="roleBadge ${roleClass}">${fmtRole(p.role)}</span></td>
          <td>${p.karma ?? 0}</td>
        `;
        lbBody.appendChild(tr);
      });

      // Rank for current player
      if(playerId){
        const myIdx = arr.findIndex(p => p.id === playerId);
        rankVal.textContent = myIdx >= 0 ? `Hạng: ${myIdx+1}/${arr.length}` : `Hạng: —`;
      }
    }

    function escapeHtml(s){
      return (s||"").replace(/[&<>"']/g, (c) => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"}[c]));
    }

    // ====== 10) MAIN PANELS ======
    async function getState(){
      const [stSnap, incSnap, plSnap] = await Promise.all([
        get(r("game/state")),
        get(r("incidents/current")),
        get(r("players"))
      ]);
      return {
        state: stSnap.val() || {},
        incident: incSnap.val() || null,
        players: plSnap.val() || {}
      };
    }

    function renderMain(){
      if(!isReady || !player){
        mainPanel.innerHTML = `<div class="notice">Chưa tham gia.</div>`;
        return;
      }

      if(IS_ADMIN_VIEW){
        panelTitle.textContent = "ADMIN DASHBOARD";
        renderAdminPanel();
        return;
      }

      if(player.role === "future"){
        panelTitle.textContent = "TƯƠNG LAI — BÁO CÁO LỖI";
        renderFuturePanel();
        return;
      }
      if(player.role === "present"){
        panelTitle.textContent = "HIỆN TẠI — THỰC THI SỬA LỖI";
        renderPresentPanel();
        return;
      }
      if(player.role === "past"){
        panelTitle.textContent = "QUÁ KHỨ — CHẾ TẠO CÔNG CỤ";
        renderPastPanel();
        return;
      }

      panelTitle.textContent = "QUAN SÁT";
      mainPanel.innerHTML = `<div class="notice">Phòng đã đủ 43 người. Thiết bị này ở chế độ quan sát.</div>`;
    }

    function renderFuturePanel(){
      const inc = liveIncident;
      if(!inc || inc.status !== "active"){
        mainPanel.innerHTML = `
          <div class="notice">Chưa có sự cố hoặc sự cố đã được xử lý. Hãy chờ…</div>
        `;
        return;
      }

      const dur = Math.max(1, (inc.deadlineAt||0) - (inc.startedAt||0));
      const left = Math.max(0, (inc.deadlineAt||0) - now());
      const pct = clamp((left/dur)*100, 0, 100);

      mainPanel.innerHTML = `
        <div class="monoBlock">${escapeHtml(inc.futureReport || "[FUTURE] …")}</div>
        <div style="height:12px"></div>
        <div class="muted small">HEALTH BAR (tụt dần): <span id="futureHealthLabel">${Math.floor(left/1000)}s</span></div>
        <div class="bar red" style="margin-top:8px"><i id="futureHealthFill" style="width:${pct}%"></i></div>
        <div style="height:10px"></div>
        <div class="notice">
          <div><b>Nhiệm vụ:</b> HÃY HÉT sự cố cho nhóm Hiện Tại.</div>
          <div class="muted" style="margin-top:6px">Bạn không có nút sửa lỗi. Bạn là “mắt nhìn tương lai”.</div>
        </div>
      `;
    }
    function renderPresentPanel(){
      const state = liveState || {};
      const incident = liveIncident || null;
      if(state.phase === "bad_end" || state.phase === "true_end") return;

      if(!incident || incident.status !== "active"){
        mainPanel.innerHTML = `<div class="notice">Chưa có sự cố. Chờ tín hiệu từ hệ thống…</div>`;
        return;
      }

      const toolReady = !!incident.toolReady;
      const disabledText = toolReady ? "" : "Công nghệ chưa được phát minh";
      const required = incident.requiredTool;

      const canFix = toolReady && incident.status === "active";
      const label = incident.presentAction || "Thực thi";

      mainPanel.innerHTML = `
        <div class="monoBlock">${escapeHtml("[PRESENT] Nhiệm vụ: " + (incident.title||"Sự cố") + "\n" + (incident.presentHint||""))}</div>
        <div style="height:12px"></div>
        <div class="notice">
          <div><b>Công cụ cần:</b> <span class="tag">${escapeHtml(required || "—")}</span></div>
          <div class="muted" style="margin-top:6px">Khi Quá Khứ giải đố xong, nút sẽ được mở khóa.</div>
        </div>
        <div style="height:12px"></div>
        <div class="btnrow">
          <button id="btnFix" class="btnPrimary" ${canFix ? "" : "disabled"}>${escapeHtml(label)}</button>
          <button id="btnAsk" ${toolReady ? "disabled" : ""}>Yêu cầu Quá Khứ chế tạo</button>
        </div>
        <div style="height:10px" class="muted small">${escapeHtml(disabledText)}</div>
      `;

      const btnFix = $("btnFix");
      const btnAsk = $("btnAsk");

      btnAsk?.addEventListener("click", async () => {
        // atomic ping
        await runTransaction(r("incidents/current"), (inc) => {
          if(!inc || inc.status !== "active") return inc;
          inc.requestedBy = playerId;
          inc.requestedAt = Date.now();
          inc.requestPing = (inc.requestPing || 0) + 1;
          return inc;
        });
      });

      btnFix?.addEventListener("click", async () => {
        await attemptFixIncident();
      });
    }

    async function attemptFixIncident(){
      const incRef = r("incidents/current");
      // lock: only 1 person can fix successfully
      const res = await runTransaction(incRef, (inc) => {
        if(!inc || inc.status !== "active") return inc;
        if(!inc.toolReady) return inc;
        inc.status = "fixed";
        inc.fixedBy = playerId;
        inc.fixedAt = Date.now();
        return inc;
      });

      if(!res.committed) return;
      const inc = res.snapshot.val();
      if(!inc || inc.status !== "fixed" || inc.fixedBy !== playerId) return;

      // Decrease chaos (atomic)
      await runTransaction(r("game/state/chaos"), (c) => {
        c = (typeof c === "number") ? c : CHAOS_START;
        return clamp(c - CHAOS_STEP_DOWN, 0, 100);
      });

      // Award karma
      await runTransaction(r(`players/${playerId}/karma`), (k) => (k||0) + KARMA.presentFix);

      // Small UX
      try{navigator.vibrate?.(60);}catch{}
    }
    function renderPastPanel(){
      const state = liveState || {};
      const incident = liveIncident || null;
      if(state.phase === "bad_end" || state.phase === "true_end") return;

      if(!incident || incident.status !== "active"){
        mainPanel.innerHTML = `<div class="notice">Chưa có yêu cầu công cụ. Chờ Hiện Tại ping…</div>`;
        return;
      }

      const tool = incident.requiredTool;
      const toolReady = !!incident.toolReady;
      const req = incident.requestedBy;
      const requesterName = req && livePlayers && livePlayers[req] ? (livePlayers[req].name || req) : (req || "");
      const requester = requesterName ? `Yêu cầu từ: ${escapeHtml(requesterName)}` : "Chưa có người yêu cầu";

      // choose puzzle per incident
      const puzzleIdx = (incident.puzzleIdx ?? 0);
      const list = (PUZZLES[tool] || []);
      const puzzle = list[puzzleIdx % (list.length || 1)];

      if(!puzzle){
        mainPanel.innerHTML = `<div class="notice">Không có puzzle cho tool: ${escapeHtml(tool||"?")}</div>`;
        return;
      }

      mainPanel.innerHTML = `
        <div class="notice">
          <div><b>Tool cần chế tạo:</b> <span class="tag">${escapeHtml(tool || "—")}</span></div>
          <div class="muted" style="margin-top:6px">${requester}</div>
        </div>
        <div style="height:12px"></div>
        <div class="monoBlock">${escapeHtml(puzzle.q)}</div>
        <div style="height:12px"></div>
        <label class="muted small">Trả lời</label>
        <input id="pastAnswer" placeholder="Nhập đáp án…" ${toolReady ? "disabled" : ""}/>
        <div style="height:10px"></div>
        <div class="btnrow">
          <button id="btnSubmitPuzzle" class="btnPrimary" ${toolReady ? "disabled" : ""}>Gửi đáp án</button>
          <button id="btnNewPuzzle" ${toolReady ? "disabled" : ""}>Đổi câu</button>
        </div>
        <div style="height:10px" class="muted small">Giải đúng → mở khóa nút Hiện Tại.</div>
      `;

      const pastAnswer = $("pastAnswer");
      const btnSubmitPuzzle = $("btnSubmitPuzzle");
      const btnNewPuzzle = $("btnNewPuzzle");

      btnNewPuzzle?.addEventListener("click", async () => {
        await runTransaction(r("incidents/current/puzzleIdx"), (x) => (x||0)+1);
      });

      btnSubmitPuzzle?.addEventListener("click", async () => {
        const raw = pastAnswer?.value || "";
        const ans = normalizeAnswer(raw);
        const ok = (puzzle.a || []).some(x => normalizeAnswer(x) === ans);

        if(!ok){
          await runTransaction(r(`players/${playerId}/wrong`), (w) => (w||0)+1);
          flashToast("Sai. Thử lại.", true);
          try{navigator.vibrate?.([40,40,40]);}catch{}
          return;
        }

        // speed bonus
        const startedAt = incident.startedAt || Date.now();
        const sec = Math.max(1, Math.floor((Date.now()-startedAt)/1000));
        const bonus = clamp(Math.round(KARMA.speedBonusMax * (1 - Math.min(sec, 45)/45)), 0, KARMA.speedBonusMax);

        // Mark toolReady (atomic)
        const incRef = r("incidents/current");
        const res = await runTransaction(incRef, (inc) => {
          if(!inc || inc.status !== "active") return inc;
          if(inc.toolReady) return inc;
          inc.toolReady = true;
          inc.toolReadyBy = playerId;
          inc.toolReadyAt = Date.now();
          return inc;
        });

        if(res.committed){
          await runTransaction(r(`players/${playerId}/karma`), (k) => (k||0) + KARMA.pastSolve + bonus);
          flashToast(`ĐÚNG. Đã mở khóa cho Hiện Tại (+${KARMA.pastSolve + bonus})`, false);
          try{navigator.vibrate?.(90);}catch{}
        }
      });
    }

    function flashToast(msg, danger){
      const el = document.createElement("div");
      el.textContent = msg;
      el.style.position = "fixed";
      el.style.left = "50%";
      el.style.bottom = "18px";
      el.style.transform = "translateX(-50%)";
      el.style.padding = "10px 12px";
      el.style.borderRadius = "14px";
      el.style.zIndex = 500;
      el.style.border = danger ? "1px solid rgba(255,92,122,.45)" : "1px solid rgba(124,255,220,.35)";
      el.style.background = "rgba(0,0,0,.35)";
      el.style.boxShadow = "0 12px 30px rgba(0,0,0,.55)";
      el.style.opacity = "0";
      el.style.transition = "opacity .16s ease, transform .16s ease";
      document.body.appendChild(el);
      requestAnimationFrame(() => { el.style.opacity = "1"; el.style.transform = "translateX(-50%) translateY(-2px)"; });
      setTimeout(() => {
        el.style.opacity = "0";
        el.style.transform = "translateX(-50%) translateY(6px)";
        setTimeout(() => el.remove(), 240);
      }, 1600);
    }

    // ====== 11) ADMIN / HOST LOOP ======
    let hostLoopTimer = null;

    async function ensureGameInitialized(){
      const st = (await get(r("game/state"))).val();
      if(st && typeof st.chaos === "number") return;
      await set(r("game/state"), {
        chaos: CHAOS_START,
        phase: "chaos",
        countdownEndsAt: 0,
        top1PlayerId: "",
        endgameArmed: false,
        updatedAt: Date.now()
      });
      // Start with an incident
      const cur = (await get(r("incidents/current"))).val();
      if(!cur || cur.status !== "active"){
        await spawnIncident();
      }
    }

    async function spawnIncident(){
      const pick = INCIDENTS[Math.floor(Math.random()*INCIDENTS.length)];
      const durationMs = 45000; // 45s for health bar
      const startedAt = Date.now();
      const deadlineAt = startedAt + durationMs;
      const tool = pick.requiredTool;
      const puzzleCount = (PUZZLES[tool] || []).length || 1;
      const puzzleIdx = Math.floor(Math.random()*puzzleCount);

      await set(r("incidents/current"), {
        status: "active",
        title: pick.title,
        futureReport: pick.futureReport,
        presentAction: pick.presentAction,
        presentHint: "Yêu cầu Quá Khứ chế tạo công cụ tương ứng, sau đó thực thi sửa lỗi.",
        requiredTool: tool,
        toolReady: false,
        toolReadyBy: "",
        startedAt,
        deadlineAt,
        requestedBy: "",
        requestedAt: 0,
        requestPing: 0,
        puzzleIdx
      });

      // Also mirror to a simple path for Future readability
      await set(r("incidents/summary"), {
        text: pick.futureReport,
        startedAt,
        deadlineAt
      });
    }

    async function hostTick(){
      const data = await getState();
      const st = data.state || {};
      const inc = data.incident || null;

      // Auto trigger endgame when chaos <= threshold
      const chaos = (typeof st.chaos === "number") ? st.chaos : CHAOS_START;
      if(st.phase !== "bad_end" && st.phase !== "true_end"){
        if(chaos <= ENDGAME_THRESHOLD && st.phase !== "endgame"){
          await triggerEndgame(data.players);
          return;
        }
      }

      if(st.phase === "endgame"){
        // if countdown hits 0 and nobody solved true end, do nothing; Top1 likely finalize.
        return;
      }

      // Manage incident lifecycle
      if(!inc || inc.status !== "active"){
        // If fixed, spawn new unless in endgame
        if(st.phase === "chaos" || st.phase === "glitch"){
          await spawnIncident();
        }
        return;
      }

      // Deadline passed
      if(inc.deadlineAt && now() > inc.deadlineAt && inc.status === "active"){
        // penalty: chaos +5 (cap 100), then spawn next
        await runTransaction(r("game/state/chaos"), (c) => {
          c = (typeof c === "number") ? c : CHAOS_START;
          return clamp(c + 5, 0, 100);
        });
        await update(r("incidents/current"), { status: "expired", expiredAt: Date.now() });
        await spawnIncident();
      }

      // Optional phase glitch (when chaos <= 20)
      if(chaos <= 20 && st.phase === "chaos"){
        await update(r("game/state"), { phase: "glitch", updatedAt: Date.now() });
      }
    }

    function startHostLoop(){
      if(!HAS_ADMIN_POWER) return;
      if(hostLoopTimer) return;
      hostLoopTimer = setInterval(() => {
        hostTick().catch(console.error);
      }, 1000);
    }

    async function renderAdminPanel(){
      const state = liveState || {};
      const incident = liveIncident || null;
      const players = livePlayers || {};

      const chaos = (typeof state.chaos === "number") ? state.chaos : CHAOS_START;
      const can = HAS_ADMIN_POWER;

      const activeCount = Object.values(players).filter(p => p && p.role && ["future","present","past"].includes(p.role)).length;
      const roomJoinUrl = (() => {
        const url = new URL(location.href);
        url.searchParams.delete("admin");
        url.searchParams.delete("key");
        url.searchParams.set("room", ROOM_ID);
        return url.toString();
      })();

      const incLine = incident && incident.status === "active"
        ? `${incident.title} | tool=${incident.requiredTool} | ready=${incident.toolReady ? "YES" : "NO"}`
        : "(không có sự cố active)";

      const gateBox = can
        ? `<div class="notice"><b>HOST MODE</b> đang bật. Bạn điều khiển nhịp game + auto-spawn + auto-endgame.</div>`
        : `<div class="notice"><b>READ-ONLY</b>: Thêm <b>&amp;key=...</b> vào URL và đổi <b>ADMIN_KEY</b> trong file để bật quyền host.</div>`;

      mainPanel.innerHTML = `
        ${gateBox}
        <div style="height:12px"></div>

        <div class="kpi">
          <div class="box">
            <div class="t">PHÒNG</div>
            <div class="v">${escapeHtml(ROOM_ID)}</div>
            <div class="muted small" style="margin-top:6px">Người chơi: <b>${activeCount}</b>/43</div>
          </div>
          <div class="box">
            <div class="t">SỰ CỐ HIỆN TẠI</div>
            <div class="v" style="font-size:13px">${escapeHtml(incLine)}</div>
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="notice">
          <div class="muted small">Link cho người chơi:</div>
          <div class="monoBlock" style="margin-top:8px">${escapeHtml(roomJoinUrl)}</div>
          <div class="muted small" style="margin-top:8px">Mở admin: thêm <b>?admin=1&amp;key=...</b> vào link laptop.</div>
        </div>

        <div style="height:12px"></div>

        <div class="btnrow">
          <button class="btnPrimary" id="btnAdminSpawn" ${can?"":"disabled"}>Tạo sự cố mới</button>
          <button id="btnAdminReset" ${can?"":"disabled"}>Reset game</button>
          <button class="btnDanger" id="btnForceEndgame" ${can?"":"disabled"}>Force Endgame</button>
        </div>

        <div style="height:12px"></div>

        <div class="card" style="background:rgba(0,0,0,.08)">
          <div class="hd"><h2>CONTROL CHAOS</h2></div>
          <div class="bd">
            <div class="btnrow">
              <button id="btnChaosPlus" ${can?"":"disabled"}>+5</button>
              <button id="btnChaosMinus" ${can?"":"disabled"}>-5</button>
              <button id="btnChaos50" ${can?"":"disabled"}>Set 50</button>
              <button id="btnChaos5" ${can?"":"disabled"}>Set 5</button>
              <button id="btnChaos1" ${can?"":"disabled"}>Set 1</button>
              <button id="btnChaos0" class="btnDanger" ${can?"":"disabled"}>Set 0</button>
            </div>
          </div>
        </div>

        <div style="height:12px"></div>

        <div class="notice">
          <div><b>Nhắc:</b> Khi Chaos ≤ 5% sẽ tự vào Endgame (60s). Top 1 thấy nút finalize (to) + override (nhỏ). Code đúng: <b>LIVE_1%</b></div>
        </div>
      `;

      if(!can) return;

      $("btnAdminSpawn")?.addEventListener("click", async () => { await spawnIncident(); });

      $("btnAdminReset")?.addEventListener("click", async () => {
        if(!confirm("Reset toàn bộ game?")) return;
        await set(r("game"), {
          joinCounter: 0,
          state: {
            chaos: CHAOS_START,
            phase: "chaos",
            countdownEndsAt: 0,
            top1PlayerId: "",
            endgameArmed: false,
            updatedAt: Date.now()
          }
        });
        await set(r("incidents"), {});
        // Keep players but reset scores + glitch
        const ids = Object.keys(players || {});
        await Promise.all(ids.map(id => update(r(`players/${id}`), {
          karma: 0,
          wrong: 0,
          slowCount: 0,
          glitched: false,
          hintPiece: ""
        })));
        await spawnIncident();
      });

      $("btnForceEndgame")?.addEventListener("click", async () => {
        await triggerEndgame(players);
      });

      const chaosSet = async (val) => update(r("game/state"), { chaos: clamp(val,0,100), updatedAt: Date.now() });
      $("btnChaosPlus")?.addEventListener("click", async () => chaosSet(chaos + 5));
      $("btnChaosMinus")?.addEventListener("click", async () => chaosSet(chaos - 5));
      $("btnChaos50")?.addEventListener("click", async () => chaosSet(50));
      $("btnChaos5")?.addEventListener("click", async () => chaosSet(5));
      $("btnChaos1")?.addEventListener("click", async () => chaosSet(1));
      $("btnChaos0")?.addEventListener("click", async () => chaosSet(0));
    }

    // ====== 12) ENDGAME LOGIC (THE TRAP) ======
    async function triggerEndgame(playersObj){
      const players = Object.values(playersObj || {})
        .filter(p => p && p.role && ["future","present","past"].includes(p.role));

      // Top 1 by karma
      const sortedDesc = [...players].sort((a,b) => (b.karma||0)-(a.karma||0) || (a.connectedAt||0)-(b.connectedAt||0));
      const top1 = sortedDesc[0];

      // Pick 5 lowest (random among bottom 10 to avoid too obvious)
      const sortedAsc = [...players].sort((a,b) => (a.karma||0)-(b.karma||0) || (b.wrong||0)-(a.wrong||0));
      const pool = sortedAsc.slice(0, Math.min(10, sortedAsc.length));
      const pick5 = [];
      const used = new Set();
      while(pick5.length < Math.min(5, pool.length)){
        const i = Math.floor(Math.random()*pool.length);
        if(used.has(i)) continue;
        used.add(i);
        pick5.push(pool[i]);
      }

      // Assign hint pieces
      const shuffledHints = [...HINT_PIECES].sort(() => Math.random() - 0.5);

      // Update state
      await update(r("game/state"), {
        phase: "endgame",
        countdownEndsAt: Date.now() + ENDGAME_SECONDS*1000,
        top1PlayerId: top1?.id || "",
        endgameArmed: true,
        updatedAt: Date.now()
      });

      // Mark glitched
      const updates = [];
      const glitchedIds = new Set(pick5.map(p => p.id));

      for(const p of players){
        if(glitchedIds.has(p.id)){
          const piece = shuffledHints[pick5.findIndex(x => x.id === p.id)] || "";
          updates.push(update(r(`players/${p.id}`), { glitched: true, hintPiece: piece }));
        } else {
          updates.push(update(r(`players/${p.id}`), { glitched: false, hintPiece: "" }));
        }
      }

      await Promise.all(updates);
    }

    // Player-side endgame UI for Top1
    async function maybeRenderEndgamePanel(){
      const { state, players } = await getState();
      if(state.phase !== "endgame") return false;

      const top1Id = state.top1PlayerId || "";
      if(playerId !== top1Id) return false;

      // Render trap interface
      mainPanel.innerHTML = `
        <div class="notice">
          <div class="big">CHỈ TOP 1 ĐƯỢC QUYỀN THỰC THI GIAO THỨC CUỐI</div>
          <div class="muted" style="margin-top:8px">Cả hệ thống đang gào: “Đưa về 0%!”</div>
        </div>
        <div style="height:12px"></div>
        <div class="btnrow">
          <button id="btn-finalize" class="btnShimmer" style="font-size:18px;padding:16px 18px;flex:1">HOÀN TẤT ĐỒNG BỘ — ĐƯA VỀ 0%</button>
          <button id="btn-override" title="MANUAL OVERRIDE">BỎ QUA</button>
        </div>
        <div style="height:12px"></div>
        <div id="overrideArea" style="display:none">
          <label class="muted small">Nhập mã (ghép từ những người Glitch)</label>
          <input id="overrideCode" placeholder="VD: LIVE_1%" />
          <div style="height:10px"></div>
          <div class="btnrow">
            <button id="btnSubmitOverride" class="btnPrimary">Xác nhận</button>
          </div>
        </div>
        <div style="height:10px" class="muted small">(Nút override nhỏ xíu — cố ý khó thấy.)</div>
      `;

      $("btn-finalize")?.addEventListener("click", async () => {
        await triggerBadEnding();
      });

      $("btn-override")?.addEventListener("click", async () => {
        $("overrideArea").style.display = "block";
        $("overrideCode")?.focus();
      });

      $("btnSubmitOverride")?.addEventListener("click", async () => {
        const code = (($("overrideCode")?.value || "").trim());
        if(code === "LIVE_1%"){
          await triggerTrueEnding();
        } else {
          flashToast("Sai mã.", true);
        }
      });

      return true;
    }

    async function triggerBadEnding(){
      // Set chaos to 0 and phase to bad_end
      await update(r("game/state"), {
        chaos: 0,
        phase: "bad_end",
        updatedAt: Date.now()
      });
    }

    async function triggerTrueEnding(){
      await update(r("game/state"), {
        chaos: CHAOS_TRUE_END,
        phase: "true_end",
        updatedAt: Date.now()
      });
    }

    // ====== 13) RERENDER HOOKS (ENDGAME UI OVERRIDES) ======
    const originalRenderMain = renderMain;
    renderMain = async function(){
      if(!isReady || !player) return originalRenderMain();

      // If endgame and top1, show special UI
      try{
        const { state } = await getState();
        if(!IS_ADMIN_VIEW && state.phase === "endgame"){
          const shown = await maybeRenderEndgamePanel();
          if(shown) return;
          // Non-top1 endgame UI
          panelTitle.textContent = "ENDGAME";
          mainPanel.innerHTML = `
            <div class="notice">
              <div class="big">CHỈ TOP 1 ĐƯỢC QUYỀN BẤM</div>
              <div class="muted" style="margin-top:8px">Nếu bạn thuộc nhóm Glitch, hãy chạy lên nói điều mình thấy.</div>
            </div>
            <div style="height:12px"></div>
            <div class="monoBlock">[SYSTEM] Đồng hồ đang đếm ngược. Áp lực tăng dần…</div>
          `;
          return;
        }
      }catch{}

      return originalRenderMain();
    };
    // Lightweight UI ticker (không đọc DB): cập nhật countdown + health bar theo thời gian
    setInterval(() => {
      if(!isReady) return;

      // Endgame countdown
      if(liveState && liveState.phase === "endgame"){
        renderCountdown(liveState);
      }

      // Future health bar animation
      if(!IS_ADMIN_VIEW && player?.role === "future"){
        const inc = liveIncident;
        if(inc && inc.status === "active"){
          const dur = Math.max(1, (inc.deadlineAt||0) - (inc.startedAt||0));
          const left = Math.max(0, (inc.deadlineAt||0) - now());
          const pct = clamp((left/dur)*100, 0, 100);
          const fill = document.getElementById("futureHealthFill");
          if(fill) fill.style.width = pct + "%";
          const lab = document.getElementById("futureHealthLabel");
          if(lab) lab.textContent = `${Math.floor(left/1000)}s`;
        }
      }
    }, 250);


    // ====== 14) START ======
    boot();
  </script>
</body>
</html>
